<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-refactoring/refactoring 2장">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">리팩토링 2장 | sjhello Wiki</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://sjhello.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://sjhello.github.io/wiki/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://sjhello.github.io/wiki/docs/refactoring/refactoring 2장"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="리팩토링 2장 | sjhello Wiki"><meta data-rh="true" name="description" content="리팩터링 책 2장에 대해 정리"><meta data-rh="true" property="og:description" content="리팩터링 책 2장에 대해 정리"><link data-rh="true" rel="icon" href="/wiki/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://sjhello.github.io/wiki/docs/refactoring/refactoring 2장"><link data-rh="true" rel="alternate" href="https://sjhello.github.io/wiki/docs/refactoring/refactoring 2장" hreflang="en"><link data-rh="true" rel="alternate" href="https://sjhello.github.io/wiki/docs/refactoring/refactoring 2장" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/wiki/blog/rss.xml" title="sjhello Wiki RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/blog/atom.xml" title="sjhello Wiki Atom Feed"><link rel="stylesheet" href="/wiki/assets/css/styles.3abdc6bc.css">
<link rel="preload" href="/wiki/assets/js/runtime~main.34294515.js" as="script">
<link rel="preload" href="/wiki/assets/js/main.4992ff73.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/"><div class="navbar__logo"><img src="/wiki/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/wiki/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">sjhello Wiki</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/wiki/docs/intro">Wiki</a><a class="navbar__item navbar__link" href="/wiki/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/sjhello" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently dark mode)" aria-label="Switch between dark and light mode (currently dark mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/wiki/docs/intro">Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/wiki/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tutorial - Basics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/wiki/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tutorial - Extras&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/wiki/docs/refactoring/refactoring 2장">refactoring</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/wiki/docs/refactoring/refactoring 2장">리팩토링 2장</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/wiki/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">refactoring</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">리팩토링 2장</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>리팩토링 2장</h1><h1>리팩터링 원칙</h1><blockquote><p>리팩터링 책 2장에 대해 정리</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링-정의">리팩터링 정의<a href="#리팩터링-정의" class="hash-link" aria-label="Direct link to 리팩터링 정의" title="Direct link to 리팩터링 정의">​</a></h2><hr><blockquote><ul><li>리팩터링: <!-- -->[명사]<!-- --> 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법 <br></li><li>리팩터링(하다): <!-- -->[동사]<!-- --> 소프트웨어의 겉보기 동작은 그대로 유지한채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.</li></ul></blockquote><p><em>누군가 &quot;리팩터링 하다가 코드가 깨져서 며칠이나 고생했다&quot; 라고 한다면, 십중팔구 리팩터링한 것이 아니다.</em></p><blockquote><ul><li>동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어 내는 일</li><li>리팩터링 하는 동안에는 코드가 항상 정상 동작하기 때문에 리팩터링 작업이 끝나지 않았더라도 언제든 멈출 수 있다.</li><li>기능을 추가하지 않는 한 사용자 관점에서는 달라지는 점이 없어야 한다.</li></ul></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="두개의-모자">두개의 모자<a href="#두개의-모자" class="hash-link" aria-label="Direct link to 두개의 모자" title="Direct link to 두개의 모자">​</a></h2><hr><blockquote><p>켄트 백은 <em>&#x27;기능 추가&#x27;</em>, 아니면 <em>&#x27;리팩터링&#x27;</em>을 구분해 두 개의 모자에 비유했다.</p></blockquote><ul><li>한번에 한 가지만 할 것을 강조<ul><li>‘기능 추가’ 모자를 쓴 다음에는 기존 코드를 절대 건드리지 않고 기능 추가에만 집중</li><li>‘리팩터링’ 모자를 쓴다면 기능 추가는 절대로 하지 않고 오로지 코드 재구성에만 집중</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링하는-이유">리팩터링하는 이유<a href="#리팩터링하는-이유" class="hash-link" aria-label="Direct link to 리팩터링하는 이유" title="Direct link to 리팩터링하는 이유">​</a></h2><hr><blockquote><p><em>리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다. 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.</em></p></blockquote><ul><li>소프트웨어 설계가 좋아진다.<ul><li>코드 설계 파악이 어려워질수록 설계를 유지하기 힘들고 설계가 부패되는 속도는 빨라진다.</li><li>같은 일을 하더라도 설계가 나쁘면 코드가 길어지고, 사실상 같은 일을 하는 코드가 여러곳에 나타날 수 있다.<ul><li>낮은 응집도</li></ul></li><li>코드가 길면 이해해야 할 코드량이 늘고 비슷한 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다.</li><li>중복코드의 제거는 언제나 고유한 일을 수행함을 보장하기 때문에 바람직한 설계의 핵심이다.</li></ul></li><li>소프트웨어를 이해하기 쉬워진다.<ul><li>미래의 나 자신을 위해 코드를 깔끔하게 유지하는게 좋다.</li><li>기억 용량의 초과
</li></ul></li></ul><blockquote><p><em>&quot;코드를 보면 알 수 있는 것들은 의도적으로 기억하지 않는다&quot;. <br>
&quot;기억 용량을 초과할까봐 그래서 기억 할 필요가 있는 것들은 최대한 코드에 담으려고 한다&quot;</em></p></blockquote><ul><li><p>버그를 쉽게 찾을 수 있다.</p><ul><li>프로그램의 구조를 명확하게 다듬으면 그냥 ‘이럴 것이다’라고 가정하던 점들이 분명하게 드러나고 버그를 지나치려야 지나칠 수 없을 정도까지 명확해 진다.</li><li>켄트 백의 말<ul><li>“난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요”<ul><li>습관적으로 리팩터링을 한다고 말 하는 것 같다.</li></ul></li></ul></li></ul></li><li><p>프로그래밍 속도를 높일 수 있다.</p><ul><li><p>리팩터링을 하면 품질을 높일 수 있다는 점에는 대부분 쉽게 수긍하지만,리팩터링하는데에 시간이 드니 전체 개발 속도는 떨어질까봐 걱정한다.</p></li><li><p>리팩터링 하지 않고 기능 추가에만 집중하다 보면 초기에는 진척이 빠르지만 나중에 가서는 새 기능을 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다.</p><p><img loading="lazy" alt="DesignStaminaHypothesis" src="/wiki/assets/images/DesignStaminaHypothesis-d88cb2ea21d7e071149eda38837ac4aa.png" width="1173" height="801" class="img_ev3q">
<em><a href="https://martinfowler.com/bliki/DesignStaminaHypothesis.html" target="_blank" rel="noopener noreferrer">&lt;지구력 가설&gt;</a></em></p></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="언제-리팩터링해야-할까">언제 리팩터링해야 할까?<a href="#언제-리팩터링해야-할까" class="hash-link" aria-label="Direct link to 언제 리팩터링해야 할까?" title="Direct link to 언제 리팩터링해야 할까?">​</a></h2><hr><blockquote><p><em>한 시간 간격으로 리팩터링 한다.</em></p></blockquote><blockquote><p><strong><em>3의 법칙</em></strong></p></blockquote><p><em>돈 로버츠(Don Roberts)가 내게 제시한 가이드다</em>.</p><ol><li>처음에는 그냥 한다.</li><li>비슷한 일을 두 번째로 하게 되면 일단 계속 진행한다.</li><li>비슷한 일을 세 번째 하게 되면 리팩터링 한다.*</li></ol><ul><li>리팩터링 2판 2장 2.4절.<blockquote></blockquote></li><li>준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기<ul><li>리팩터링 하기 가장 좋은 시점은 기능 추가 하는 순간<ul><li>이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씩 쉬워질 만한 부분을 찾는다.</li><li>기존 함수를 복제하여 리팩터링 해야할 일이 있으면 <strong>함수 매개변수화하기</strong> 를 적용해보자</li></ul></li><li>버그를 잡을때에도 리팩터링 하기 좋은 시점<ul><li>만약 오류를 발생시키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한곳으로 합치는 것이 작업하기 수월하다.</li><li>질의 코드에 섞여있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 줄일 수 있다.</li></ul></li></ul></li><li>이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기</li><li>쓰레기 줍기 리팩터링</li><li>계획된 리팩터링과 수시로 하는 리팩터링</li><li>오래 걸리는 리팩터링</li><li>코드 리뷰에 리팩터링 활용하기</li><li>관리자에게는 뭐라고 말해야 할까?</li><li>리팩터링 하지 말아야 할때</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링-시-고려할-문제">리팩터링 시 고려할 문제<a href="#리팩터링-시-고려할-문제" class="hash-link" aria-label="Direct link to 리팩터링 시 고려할 문제" title="Direct link to 리팩터링 시 고려할 문제">​</a></h2><hr><ul><li>새 기능 개발 속도 저하<ul><li><p>많은 새람들이 리팩터링 때문에 새 기능 개발 속도가 저하된다고 믿고 있다.</p><blockquote><p><em>하지만 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하기 위함이다.</em></p></blockquote></li><li><p>주변 동료들의 얘기로는 리팩터링을 과도하게 하는 경우보다 거의 하지 않는 경우가 많다.</p></li><li><p>건강한 코드의 위력을 경험해 보지 않고서는 코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감하기 어렵다.</p><ul><li>그러므로 리팩터링을 더 자주, 열심히 해야 한다.</li></ul></li><li><p>오로지 경제적인 이유에서 리팩터링을 한다.</p><ul><li><strong>리팩터링을 클린코드, 바람직한 엔지니어링 습관 처럼 도덕적인 이유로 정당화 해선 안된다.</strong></li><li>본질은 생성상의 증대, 개발 기간과 버그 수정 시간을 단축하는 데에 있다.</li></ul></li></ul></li><li>코드 소유권<ul><li>리팩터링 하려고 하는 메서드의 소유권이 다른 팀에 있는 경우에는 어떻게 해야할까?</li><li>코드 소유권이 나뉘어져 있으면 리팩터링에 방해가 된다.<ul><li>코드 소유권을 작은 단위로 나누어 관리하는것에 반대한다.</li><li><strong>그것 보다, 코드 소유권을 팀 전체로 두어 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게끔 한다.</strong></li><li><strong>각자가 책임지는 영역이 있을 수 있다. 이것이 다른 사람이 코드를 수정하게 둬서는 안된다라는 말이 아니라 책임지는 영역의 변경사항을 관리하라는 의미이다.</strong><ul><li>이를 위해 코드의 브랜치를 새로 생성하고 새 브랜치에서 수정한 뒤 기존 브랜치로 pull request 하는 방식의 모델을 권장하기도 한다(오픈 소스 개발 모델)</li></ul></li></ul></li></ul></li><li>브랜치<ul><li>통합을 하지 않은채 독립 브랜치에서 계속 작업하다 보면 작업 결과를 마스터 브랜치로 통합하기가 매우 힘들어진다.<ul><li>심지어는 기능 개발의 기간보다 통합하는 기간이 훨씬 더 길어지기도 한다.</li></ul></li><li>지속적 통합(CI)과 트렁크 기반 개발(TBD)<ul><li>독립(기능) 브랜치를 마스터 브랜치로 자주 주기적으로 통합한다.</li><li>충돌이 발생하는 지점을 자주 볼 수 있기 때문에 리팩터링과 궁합이 잘 맞는다.</li><li>켄트 백은 CI와 리팩터링을 합쳐서 XP(eXtreme Programming)이라고 하였다.</li></ul></li><li><strong>통합 주기를 짧게 가져야 한다.</strong></li></ul></li><li>테스팅<ul><li>리팩터링을 시도하는 중에도 프로그램의 동작은 똑같이 유지되야 한다.<ul><li>도중에 실수하게되면 동작은 깨질 것이다.</li></ul></li><li>테스트 스위트(Test Suite)는 리팩터링을 시도하였을때 실수한 부분을 빠르게 확인할 수 있게 도와준다.<ul><li>그래서 리팩터링을 하기 위해서는 <a href="https://martinfowler.com/bliki/SelfTestingCode.html" target="_blank" rel="noopener noreferrer">자가 테스트 코드</a>를 마련하는 것이 좋다.<ul><li>새 기능 추가를 안전하게 할 수 있는데, 실수로 만든 버그를 빠르게 제거 할 수 있기 때문이다.</li><li>자신있게 리팩터링이 가능하다(리팩터링 후 → 테스트 코드 실행 → 테스트 실패 → 테스트 성공하게끔 코드 변경 → ….. 반복)</li></ul></li><li>만약 자동 리팩터링 기능 제공하는 환경(IDE)이 있다면 굳이 테스트 하지 않아도 오류가 생기지 않는다고 확신할 수 있다.</li></ul></li></ul></li><li>레거시 코드<ul><li>안타깝지만 테스트가 제대로 갖추어져 있지 않을 수 있다.<ul><li>테스트가 갖춰져 있다고 해서 레거시 코드를 단번에 리팩터링 하기란 어렵다.</li></ul></li><li>캠핑 규칙을 생각하자.<ul><li>처음 왔을때 보다 깨끗하게 치우는 것이다.</li><li>코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력한다.</li></ul></li><li>자주 보는 부분을 더 많이 리팩터링 한다.<ul><li>자주 보는 부분을 이해하기 쉽게 개선한다면 그 만큼 시간도 절약 될 것이다.</li></ul></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링-아키텍쳐-애그니yagni">리팩터링, 아키텍쳐, 애그니(YAGNI)<a href="#리팩터링-아키텍쳐-애그니yagni" class="hash-link" aria-label="Direct link to 리팩터링, 아키텍쳐, 애그니(YAGNI)" title="Direct link to 리팩터링, 아키텍쳐, 애그니(YAGNI)">​</a></h2><hr><ul><li>미래를 생각한 유연성 매커니즘<ul><li>잘못 구현한 유연성 매커니즘<ul><li>요구사항이 예상과 다르게 바뀌는 경우</li><li>설계 결함</li><li>당장의 쓰임에 비해 복잡한 함수</li></ul></li><li>변화에 대응하는 능력이 떨어질 수도 있다.</li></ul></li><li>유연성 매커니즘 보다는 리팩터링<ul><li>그저 현재까지 파악한 요구사항을 <strong>충분히 멋지게</strong> 해결하는 소프트웨어를 만든다.</li></ul></li><li>간결한 설계, 점진적 설계, YAGNI(You Aren’t Going To Need It - 필요 없을 거다)<ul><li>나중에 문제를 깊이 이해 했을때 처리하는 쪽이 훨씬 낫다.</li><li>선제적인 처리를 배척한다는 말이 아니다.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링과-소프트웨어-개발-프로세스">리팩터링과 소프트웨어 개발 프로세스<a href="#리팩터링과-소프트웨어-개발-프로세스" class="hash-link" aria-label="Direct link to 리팩터링과 소프트웨어 개발 프로세스" title="Direct link to 리팩터링과 소프트웨어 개발 프로세스">​</a></h2><hr><ul><li>3가지 기법(XP의 특징)<ul><li>리팩터링</li><li>테스트 코드<ul><li>테스트 코드는 굉장히 중요하다.</li><li>팀으로 개발하면서 리팩터링을 하려면 다른 사람의 작업을 방해 하지 않으면서 언제든지 리팩터링 할 수 있어야 한다. 이는 지속적 통합을 권장하는 이유이기도 하다.</li><li>리팩터링한 결과가 테스트 코드를 통해서 빠르게 동료와 공유 할 수 있기 때문이다.</li></ul></li><li>지속적 통합</li></ul></li><li>3가지 기법을 토대로 한 YAGNI<ul><li>위 3가지 기법과 YAGNI는 서로 긍정적인 영향을 끼친다. 3가지 기법이 YAGNI의 토대인 동시에 YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있기 때문이다.</li><li><strong>유연성 매커니즘을 많이 갖는 시스템보다 YAGNI를 준수한 시스템이 단순하기 때문에 훨씬 변경하기가 쉽다.</strong></li><li>3가지 기법과 YAGNI를 이용하면 요구사항 변화에 빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을 수 있다.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링과-성능">리팩터링과 성능<a href="#리팩터링과-성능" class="hash-link" aria-label="Direct link to 리팩터링과 성능" title="Direct link to 리팩터링과 성능">​</a></h2><hr><ul><li>성능 VS 직관적인 설계<blockquote><p><em>필자는 실제로 소프트웨어를 이해하기 쉽게 만들기 위해 속도가 느려지는 방향으로 수정하는 경우도 많다고 한다.</em></p></blockquote></li><li>리팩터링 하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 리팩터링을 하면 성능 튜닝 하기에는 쉬워진다.<ul><li>(<em>코드베이스가 건강하고 설계가 직관적이기 때문일 것 같다)</em></li></ul></li><li>대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다. 즉 코드베이스 일부분에서 성능 이슈가 발생하는 것이다.<ul><li>때문에 전체 코드를 고르게 최적화 한다고 하여도 효과는 미비하기 때문에 시간 낭비인 셈이다.</li></ul></li><li><strong>어차피 시간 낭비이기 때문에 성능에 대해서는 신경 쓰지않고 코드를 다루기 쉽게 만드는 것에 집중한다.</strong><ul><li>성능 최적화 단계에 돌입하기 전까지 지속적으로 코드를 다루기 쉽게 만드는 것에 집중한다.</li><li>성능 최적화 단계에 돌입하면 리팩터링할 때처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다.<ul><li>성능 개선에 실패하면 되돌아 가고 성공하면 커밋한다.</li></ul></li><li><strong>이렇게 할 수 있는 이유는 평소에 코드를 다루기 쉽게 만드는 것에 집중했기 때문이고, 두 가지 이점이 생긴다.</strong><ul><li>첫번째 성능 튜닝 시간을 벌 수 있다. 리팩터링이 잘 되어 있기 때문에 기능 추가가 빨리 끝나서 성능에 집중할 시간을 번 것 이다.</li><li>두번째 성능을 더 세밀하게 분석할 수 있다. 이 역시 리팩터링이 잘 되어 있기 때문에 프로파일 도구가 지적해주는 코드의 범위가 좁아 진다. 따라서 튜닝하기가 쉬워진다.</li></ul></li></ul></li><li>결국 리팩터링은 성능 좋은 프로그램을 만드는데 기여한다. 단기적으로 보면 성능이 느려질 수는 있으나 건강한 코드베이스를 유지하는 데에 노력하였기 때문에 중요한 일(성능 최적화)을 할때에 힘을 낼 수 있는 것이다.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링의-유래">리팩터링의 유래<a href="#리팩터링의-유래" class="hash-link" aria-label="Direct link to 리팩터링의 유래" title="Direct link to 리팩터링의 유래">​</a></h2><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="리팩터링-자동화">리팩터링 자동화<a href="#리팩터링-자동화" class="hash-link" aria-label="Direct link to 리팩터링 자동화" title="Direct link to 리팩터링 자동화">​</a></h2><hr><h1>더 읽어보면 좋을 것 들</h1><hr><ul><li>Building Evolutionary Architectures</li><li>클린 아키텍처</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/sjhello/Wiki/blob/main/docs/refactoring/refactoring 2장.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-07-02T04:09:17.000Z">Jul 2, 2023</time></b> by <b>sjhello</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/wiki/docs/tutorial-extras/translate-your-site"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Translate your site</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#리팩터링-정의" class="table-of-contents__link toc-highlight">리팩터링 정의</a></li><li><a href="#두개의-모자" class="table-of-contents__link toc-highlight">두개의 모자</a></li><li><a href="#리팩터링하는-이유" class="table-of-contents__link toc-highlight">리팩터링하는 이유</a></li><li><a href="#언제-리팩터링해야-할까" class="table-of-contents__link toc-highlight">언제 리팩터링해야 할까?</a></li><li><a href="#리팩터링-시-고려할-문제" class="table-of-contents__link toc-highlight">리팩터링 시 고려할 문제</a></li><li><a href="#리팩터링-아키텍쳐-애그니yagni" class="table-of-contents__link toc-highlight">리팩터링, 아키텍쳐, 애그니(YAGNI)</a></li><li><a href="#리팩터링과-소프트웨어-개발-프로세스" class="table-of-contents__link toc-highlight">리팩터링과 소프트웨어 개발 프로세스</a></li><li><a href="#리팩터링과-성능" class="table-of-contents__link toc-highlight">리팩터링과 성능</a></li><li><a href="#리팩터링의-유래" class="table-of-contents__link toc-highlight">리팩터링의 유래</a></li><li><a href="#리팩터링-자동화" class="table-of-contents__link toc-highlight">리팩터링 자동화</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 sjhello, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/wiki/assets/js/runtime~main.34294515.js"></script>
<script src="/wiki/assets/js/main.4992ff73.js"></script>
</body>
</html>